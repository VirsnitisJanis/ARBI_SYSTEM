import asyncio
import csv
import os
import time

import ccxt

from engine.maker_engine import place_maker, process_maker_order, settle_fill
from engine.smart_edge import should_open
from heartbeat import beat
from hedge_recovery import check_and_recover  # Stage-7
from notify import send
from utils.balances import get, snapshot

# KonfigurƒÅcija
PAIR = os.getenv("PAIR", "BTC/USDC")
A = os.getenv("VENUE_A", "binance")
B = os.getenv("VENUE_B", "kucoin")

NOTIONAL = float(os.getenv("NOTIONAL_USDC", "25"))
EDGE_OPEN = float(os.getenv("EDGE_OPEN_BPS", "2.0"))
EDGE_CANCEL = float(os.getenv("EDGE_CANCEL_BPS", "1.0"))
MAX_INV_BTC = float(os.getenv("MAX_INV_BTC", "0.0025"))
RESTART_DELAY = float(os.getenv("RESTART_DELAY_S", "60"))
LOG = os.getenv("LIVE_LOG", "logs/live_safe.csv")
TTL = float(os.getenv("MAKER_TTL_S", "4"))

# CCXT
ca, cb = ccxt.binance(), ccxt.kucoin()

async def heartbeat_ping(interval_s=3600):
    while True:
        try:
            send(f"üíó SYSTEM ALIVE ‚Äî {PAIR}\nSnap: {snapshot()}")
        except Exception as e:
            print("[HB ERROR]", e)
        await asyncio.sleep(interval_s)

async def run_cycle():
    maker = None
    print(f"[BOOT SAFE LIVE] {A}<->{B} {PAIR}")
    print("[INIT SNAP]", snapshot())

    os.makedirs(os.path.dirname(LOG), exist_ok=True)
    with open(LOG, "a"): pass

    while True:
        beat()

        ta, tb = await asyncio.gather(
            asyncio.to_thread(ca.fetch_ticker, PAIR),
            asyncio.to_thread(cb.fetch_ticker, PAIR)
        )
        a_bid, a_ask = ta["bid"], ta["ask"]
        b_bid, b_ask = tb["bid"], tb["ask"]

        # Inventory dro≈°ƒ´ba
        if get(A, "BTC") > MAX_INV_BTC or get(B, "BTC") > MAX_INV_BTC:
            msg = f"‚ö†Ô∏è HALT ‚Äî inventory limit hit.\nSnap: {snapshot()}"
            print(msg); send(msg)
            raise RuntimeError("inventory limit")

        # Hedge Recovery (Stage-7)
        rec = check_and_recover(a_bid, a_ask, b_bid, b_ask)
        if rec:
            await asyncio.sleep(0.25)
            continue

        # Smart Edge + PnL filtrs (Stage-12)
        open_ok, info = should_open(a_bid, a_ask, b_bid, b_ask, NOTIONAL, EDGE_OPEN)
        print(f"[EDGE] raw‚âà{info['raw_edge_bps']:.2f} net‚âà{info['net_bps']:.2f} "
              f"spread_min‚âà{info['min_internal_spread_bps']:.2f} "
              f"est_pnl‚âà{info['est_pnl_usd']:.5f} | maker={maker} | reason={info['reason']}")

        # log tick
        with open(LOG, "a", newline="") as f:
            csv.writer(f).writerow([time.time(), a_bid, a_ask, b_bid, b_ask,
                                    info['raw_edge_bps'], info['net_bps'], "TICK"])

        # Atvƒìr≈°ana tikai tad, ja filtrs atƒºauj
        if maker is None and open_ok and get(A, "USDC") >= NOTIONAL:
            size = NOTIONAL / a_ask
            maker = place_maker("buy", A, a_bid, size)
            maker["ts"] = time.time()
            print("[PLACE]", maker)

        # Maker pƒÅrvaldƒ´ba
        if maker:
            status, reason = process_maker_order(maker, {"bid": a_bid, "ask": a_ask})

            # Timeout / edge samazinƒÅ≈°anƒÅs
            if time.time() - maker["ts"] > TTL or info['net_bps'] < EDGE_CANCEL:
                maker["expiry"] = 0
                status, reason = (False, "CANCEL")

            if status is True:
                pnl = settle_fill(maker, b_bid)
                print("[FILL]", pnl, snapshot())
                try:
                    send(f"‚úÖ HEDGE FILL {PAIR} {A}->{B}\nPnL: {pnl:.6f}\nSnap: {snapshot()}")
                except Exception as e:
                    print("[TG ERROR]", e)
                with open(LOG, "a", newline="") as f:
                    csv.writer(f).writerow([time.time(), "FILL", pnl, snapshot()])
                maker = None

            elif status is False:
                print("[EXPIRE]", reason)
                maker = None

        await asyncio.sleep(float(os.getenv("CHECK_INTERVAL_S", "0.35")))

async def loop():
    asyncio.create_task(heartbeat_ping(int(os.getenv("HEARTBEAT_S","3600"))))
    while True:
        try:
            await run_cycle()
        except Exception as e:
            print(f"[CIRCUIT BREAK] {e}")
            try:
                send(f"üö® CIRCUIT BREAK ‚Äî {e}\nCooling {RESTART_DELAY}s.")
            except Exception as te:
                print("[TG ERROR]", te)
            await asyncio.sleep(RESTART_DELAY)
            print("[RESTART] Attempting to resume trading...")
            try:
                send("üîÅ Restarting trading cycle...")
            except Exception as te:
                print("[TG ERROR]", te)
            continue

if __name__ == "__main__":
    try:
        asyncio.run(loop())
    except KeyboardInterrupt:
        print("exit")
